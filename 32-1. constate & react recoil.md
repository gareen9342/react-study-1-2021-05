# constate & react recoil

[벨로퍼트님글 ㅎ][ridi-state-mgmt]

## redux 알아보기 전에 다른 상태 관리 라이브러리도 알아봅시다!
> redux 는 빨간맛임

---

## 먼저 useState 랑 useReducer 말고.. context
> 사용할 object 를 만들고 이 것을 provider 에 담아서 사용하고 싶은 곳에 provider 로 wrap 하여, useContext 나 consumer 로 사용하는 형태.

> 사용처에 따라 global 하게 쓸 수도 있다!

> 다만.. context provider 에서 사용하는 value 에서 단 한가지라도 변경 되면, 해당 context 를 사용하는
> 컴포넌트는 무조건 re-render 가 되므로 성능이 낭비됨..

> 따라서 상태 설계 시에 개념적 분리를 넘는 물리적 분리를 잘 해줘야함! (사실 context 마다 1개의 prop 만 쓰면 ㅋㅋ..)
>
> context 는 단지 useState, useReducer + a 로 구현한 상태 관리 로직을 lift-up 해주는 수단 일뿐임~

---

[constate github repo][constate-repo]

## constate?

```bash
npm i constate
```

> 기존 context 에서 있던 성능 문제를 해결 했음.

```javascript
/** 
 * @param useValue any custom hooks. they will be populated with <Provider />
 * @param selectors split the custom hooks into multiple React Contexts (with Provider)
 *                  by passing at least one of function
*/
constate(useValue[, ...selectors])
```


```javascript
import React, { createContext, useState, useContext } from "react";

// 1. create context 
const UserContext = createContext(null);
const UserUpdateContext = createContext(null);

// 2. make provider wrapper
function UserProviderWrapper({ children }) {
  const [user, setUser] = useState(null);
  return (
    <UserContext.Provider value={user}>
      <UserUpdateContext.Provider value={setUser}>
        {children}
      </UserUpdateContext.Provider>
    </UserContext.Provider>
  );
}

// 3. make useContext factory
function useUser() {
  return useContext(UserContext);
}

function useUserUpdate() {
  return useContext(UserUpdateContext);
}

// 4. put 1~3. together into in other component
function UserInfo() {
  const user = useUser();
  if (!user) return <div>사용자 정보가 없습니다.</div>;
  return <div>{user.username}</div>;
}

function Authenticate() {
  const setUser = useUserUpdate();
  const onClick = () => {
    setUser({ username: "velopert" });
  };
  return <button onClick={onClick}>사용자 인증</button>;
}

export default function App() {
  return (
    <UserProviderWrapper>
      <UserInfo />
      <Authenticate />
    </UserProviderWrapper>
  );
}
```

를

```javascript
import React, { useState  } from "react";
import constate from 'constate';

// 1. skip creating context and provider wrapper!
function useUser() {
  // it's just same as before which we wrote inside the provider wrapper
  const [user, setUser] = useState(null);
  return { user, setUser };
}

// 2. each use** hooks after the state mgmt hook (useUser) populate with Context Provider.
// Context Provider will be produced as much as putting selectors
const [UserProvider, useUserValue, useUserUpdate] = constate(
  useUser,
  value => value.user,
  value => value.setUser
);

// 3. 
function UserInfo() {
  const user = useUserValue();
  if (!user) return <div>사용자 정보가 없습니다.</div>;
  return <div>{user.username}</div>;
}

function Authenticate() {
  const setUser = useUserUpdate();
  const onClick = () => {
    setUser({ username: "velopert" });
  };
  return <button onClick={onClick}>사용자 인증</button>;
}

export default function App() {
  return (
    <UserProvider>
      <UserInfo />
      <Authenticate />
    </UserProvider>
  );
}
```

로 변경해도

![before-constate]
![after-constate]

동일한 hierarchy 생성~
**-> selector 마다 provider 를 만들어 내부적으로 사용한다.**

그래서 얻는 장점을 정리 하자면,

- **Synchronized State**
props drilling 하면서 상태 변경 체크할 필요없음. 작성 난이도 최하~

- **Only use the State you Need**
알아서 split 되서 성능 보장.

- **Less Boilerplate** provider, createContext, useContext factory 작성 안해도 됨.

---

## react recoil

```bash
npm i recoil
```


[ridi-state-mgmt]: https://ridicorp.com/story/how-to-use-redux-in-ridi/
[constate-repo]: https://github.com/diegohaz/constate
[before-constate]: ./resources/images/before-constate.jpg "before constate alt"
[after-constate]: ./resources/images/after-constate.jpg "after constate alt"
